<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide to Linear Regression</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
            transition: all 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        .math-box {
            background-color: #eef2ff;
            border-left: 4px solid #6366f1;
            padding: 1.5rem;
            border-radius: 0.5rem;
            font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 1.1rem;
            overflow-x: auto;
            color: #312e81;
        }
        .highlight {
            background: linear-gradient(to right, #6366f1, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .code-block .comment { color: #94a3b8; }
        .code-block .keyword { color: #93c5fd; }
        .code-block .function { color: #a78bfa; }
        .code-block .number { color: #facc15; }
        .code-block .string { color: #a5f3fc; }
        .action-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
            text-align: center;
            border: none;
            cursor: pointer;
        }
        .action-button:hover {
            background-color: #4338ca;
        }
        .secondary-button {
            background-color: #e0e7ff;
            color: #4338ca;
        }
        .secondary-button:hover {
             background-color: #c7d2fe;
        }
        .text-teal-700 { color: #0f766e; }
        .text-indigo-700 { color: #4338ca; }
        .text-purple-700 { color: #7e22ce; }
        .text-orange-700 { color: #c2410c; }
        .text-red-700 { color: #b91c1c; }
        .text-blue-700 { color: #1d4ed8; }
        .text-green-700 { color: #15803d; }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold mb-2">
                The Intuitive Guide to <span class="highlight">Linear Regression</span>
            </h1>
            <p class="text-lg text-gray-600">Don't just learn the theory. Build it. See it. Understand it.</p>
        </header>

        <div class="grid grid-cols-1 gap-8">

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">The Core Idea: Finding a Simple Story in Data</h2>
                <p class="mb-4 text-gray-600 leading-relaxed">At its heart, Linear Regression is a story-teller. It looks at a cloud of data points and tries to tell the simplest, most useful story by drawing a single straight line. Its goal is to <strong>find the best possible straight line to describe the relationship in your data.</strong></p>
                <p class="mb-4 text-gray-600 leading-relaxed"><strong>Analogy:</strong> Imagine you're a real estate agent trying to understand house prices. You know that, generally, bigger houses cost more. You plot all your recent sales on a chart (like the one below). Linear Regression is the tool that draws a line through your plot, giving you a simple rule of thumb like:</p>
                <div class="math-box text-center text-lg md:text-xl">
                    Predicted Price = (Price per Square Foot × Size) + Base Value
                </div>
            </div>

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">Interactive Demo: You are the Algorithm!</h2>
                <p class="mb-6 text-gray-600">Adjust the sliders to find the "line of best fit". Your goal is to make the <strong class="text-red-700">Mean Squared Error (MSE)</strong> as small as possible. The <strong class="text-red-700">red lines</strong> show the error for each point. Notice how they shrink as your line gets better! You can also click on the chart to add or remove data points.</p>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2 relative h-[450px] bg-gray-50 rounded-lg p-2 cursor-crosshair" id="chart-container">
                        <canvas id="interactiveChart"></canvas>
                    </div>
                    <div class="flex flex-col justify-center space-y-6">
                        <div>
                            <label for="slopeSlider" class="font-semibold text-purple-700">Slope (<code>θ₁</code>): <span id="slopeValue" class="font-bold">1.00</span></label>
                            <input type="range" id="slopeSlider" min="-1" max="3" step="0.01" value="1" class="w-full h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="interceptSlider" class="font-semibold text-teal-700">Intercept (<code>θ₀</code>): <span id="interceptValue" class="font-bold">50</span></label>
                            <input type="range" id="interceptSlider" min="0" max="150" step="1" value="50" class="w-full h-2 bg-teal-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="bg-red-50 border border-red-200 rounded-lg text-center p-4">
                            <h3 class="text-lg font-bold text-red-700">Mean Squared Error (MSE)</h3>
                            <p id="mseValue" class="text-3xl font-bold text-red-600">0</p>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <button id="solveBtn" class="action-button">Solve for Me!</button>
                            <button id="resetBtn" class="action-button secondary-button">New Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                 <h2 class="text-3xl font-bold mb-4">The Mathematics Behind the Model</h2>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-bold mb-2">1. The Equation of the Line (The Hypothesis)</h3>
                        <p class="mb-4 text-gray-600">The line is described by a simple formula. In machine learning, we call this the <strong>hypothesis function</strong>, <code>h(x)</code>. It's our model's "guess" for a given input. It's just the familiar <code>y = mx + c</code> with different variable names.</p>
                        <div class="math-box">h(x) = <span class="text-teal-700">θ₀</span> + <span class="text-purple-700">θ₁</span><span class="text-orange-700">x</span></div>
                        <ul class="mt-4 space-y-3 text-sm">
                            <li><span class="font-bold text-indigo-700"><code>h(x)</code></span>: The <strong>predicted value</strong> (e.g., predicted price). This is the output of our model.</li>
                            <li><strong class="text-teal-700"><code>θ₀</code></strong> (theta-zero): The <strong>intercept</strong>. <em>Analogy: Think of this as the base value of any house, regardless of its size. It's our starting point.</em></li>
                            <li><strong class="text-purple-700"><code>θ₁</code></strong> (theta-one): The <strong>slope</strong> or <strong>coefficient</strong>. <em>Analogy: This is the "price per square foot." It tells us how much the price increases for each additional unit of size.</em></li>
                            <li><strong class="text-orange-700"><code>x</code></strong>: The <strong>input feature</strong> (e.g., house size). This is the information we know.</li>
                        </ul>
                    </div>
                    <div>
                         <h3 class="text-xl font-bold mb-2">2. Measuring Error (The Cost Function)</h3>
                        <p class="mb-4 text-gray-600">The <strong>Mean Squared Error (MSE)</strong> is our "cost function," <code>J</code>. It gives us a single number that measures how <em>bad</em> our line is. <br><strong>Analogy:</strong> Imagine each <strong class="text-red-700">red error line</strong> is a rubber band stretching from a data point to your line. The MSE is like the <em>total tension</em> in all the rubber bands combined. Your job is to find the line that makes the rubber bands as relaxed as possible.</p>
                        <div class="math-box text-sm">J(θ₀, θ₁) = (1/n) * Σ (<span class="text-green-700">h(xᵢ) - yᵢ</span>)²</div>
                         <ul class="mt-4 space-y-3 text-sm">
                            <li><strong class="text-red-700"><code>J(...)</code></strong>: The Cost Function. Our goal is to find the <code>θ₀</code> and <code>θ₁</code> that make this value as small as possible.</li>
                            <li><strong class="text-gray-600"><code>n</code></strong>: The total number of data points we have.</li>
                            <li><strong class="text-blue-700"><code>Σ</code></strong>: A fancy symbol for "sum up everything that follows."</li>
                            <li><strong class="text-green-700"><code>(h(xᵢ) - yᵢ)</code></strong>: The difference between the <strong class="text-indigo-700">predicted value</strong> and the <strong class="text-blue-700">actual value</strong> for a single data point <code>i</code>. This is the length of one red line. We square it, <code>(...)²</code>, to make the error positive and to punish larger errors much more severely than small ones.</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">How the Machine "Learns": Gradient Descent</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                    <div>
                        <p class="mb-4 text-gray-600">How does the algorithm find the best slope and intercept? It uses an elegant process called <strong>Gradient Descent</strong>. <br><strong>Analogy:</strong> Imagine the error surface on the right is a three-dimensional landscape. The position of a ball on this landscape is defined by its coordinates: the current <strong class="text-teal-700"><code>θ₀</code></strong> and <strong class="text-purple-700"><code>θ₁</code></strong>. The height of the landscape at that point is the error (MSE). The algorithm starts by placing the ball at a random position. Then, under the "gravity pull" of the gradient, the ball naturally rolls downhill, step by step, until it settles at the lowest point in the valley—the position that represents the minimum possible error.</p>
                        <p class="text-gray-600">Each step the ball takes updates our <code>θ₀</code> and <code>θ₁</code> values, moving our line on the main chart closer to the optimal solution. The size of each step is controlled by a parameter called the <strong>learning rate</strong>.</p>
                    </div>
                    <div class="h-[250px] bg-gray-100 rounded-lg p-2">
                        <canvas id="gradientDescentCanvas"></canvas>
                        <p class="text-center text-xs text-gray-500 mt-1">Visualization of the algorithm finding the lowest error by adjusting slope and intercept. The red dot is taking steps toward the center (minimum error).</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">The Code: Putting it into Practice</h2>
                <p class="mb-4 text-gray-600">While it's crucial to understand the theory, libraries like Scikit-learn in Python handle all the complex math for us in just a few lines of code.</p>
                <div class="code-block">
<pre><code><span class="comment"># Import the necessary libraries</span>
<span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># 1. Your data (e.g., House Size vs. Price)</span>
X = np.array([[<span class="number">1000</span>], [<span class="number">1500</span>], [<span class="number">2000</span>], [<span class="number">2500</span>]])  <span class="comment"># Feature (must be 2D array)</span>
y = np.array([<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">650</span>])      <span class="comment"># Target</span>

<span class="comment"># 2. Create the model instance</span>
model = <span class="function">LinearRegression</span>()

<span class="comment"># 3. Train the model (this is where Gradient Descent happens!)</span>
model.<span class="function">fit</span>(X, y)

<span class="comment"># 4. Make a prediction for a new house</span>
new_house_size = [[<span class="number">1800</span>]]
predicted_price = model.<span class="function">predict</span>(new_house_size)

<span class="function">print</span>(<span class="string">f"Predicted price for 1800 sq ft: ${predicted_price[0]:.2f}k"</span>)

<span class="comment"># The learned parameters (the 'magic' numbers)</span>
<span class="function">print</span>(<span class="string">f"Learned Slope (θ₁): {model.coef_[0]:.2f}"</span>)
<span class="function">print</span>(<span class="string">f"Learned Intercept (θ₀): {model.intercept_:.2f}"</span>)
</code></pre>
                </div>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- DOM Element Selection ---
            const slopeSlider = document.getElementById('slopeSlider');
            const interceptSlider = document.getElementById('interceptSlider');
            const slopeValueEl = document.getElementById('slopeValue');
            const interceptValueEl = document.getElementById('interceptValue');
            const mseValueEl = document.getElementById('mseValue');
            const solveBtn = document.getElementById('solveBtn');
            const resetBtn = document.getElementById('resetBtn');
            const chartContainer = document.getElementById('chart-container');
            const mainCtx = document.getElementById('interactiveChart').getContext('2d');
            const gdCtx = document.getElementById('gradientDescentCanvas').getContext('2d');

            // --- State Variables ---
            let mainChart;
            let dataPoints = [];
            let bestFitCache = null; // Cache for the optimal solution

            // --- Core Logic Functions ---

            // Calculates the Mean Squared Error for the current line
            const calculateMSE = (slope, intercept) => {
                if (dataPoints.length === 0) return 0;
                const totalError = dataPoints.reduce((sum, p) => {
                    const predictedY = slope * p.x + intercept;
                    return sum + Math.pow(predictedY - p.y, 2);
                }, 0);
                return totalError / dataPoints.length;
            };

            // Solves for the best fit line using the closed-form solution
            const solveForBestFit = () => {
                if (bestFitCache) return bestFitCache; // Use cache if available

                const n = dataPoints.length;
                if (n < 2) return { slope: 0, intercept: n === 1 ? dataPoints[0].y : 75 };

                const sumX = dataPoints.reduce((s, p) => s + p.x, 0);
                const sumY = dataPoints.reduce((s, p) => s + p.y, 0);
                const sumXY = dataPoints.reduce((s, p) => s + p.x * p.y, 0);
                const sumXX = dataPoints.reduce((s, p) => s + p.x * p.x, 0);
                
                const denominator = (n * sumXX - sumX * sumX);
                if (Math.abs(denominator) < 1e-9) return { slope: 0, intercept: sumY / n };

                const slope = (n * sumXY - sumX * sumY) / denominator;
                const intercept = (sumY - slope * sumX) / n;
                
                bestFitCache = { slope, intercept }; // Store result in cache
                return bestFitCache;
            };

            // Draws the red residual lines from each point to the regression line
            const drawResidualLines = (chart) => {
                const slope = parseFloat(slopeSlider.value);
                const intercept = parseFloat(interceptSlider.value);
                const { ctx, scales } = chart;
                ctx.save();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                
                dataPoints.forEach((point, index) => {
                    const pointElement = chart.getDatasetMeta(0).data[index];
                    if (pointElement) {
                        const predictedYPixel = scales.y.getPixelForValue(slope * point.x + intercept);
                        ctx.beginPath();
                        ctx.moveTo(pointElement.x, pointElement.y);
                        ctx.lineTo(pointElement.x, predictedYPixel);
                        ctx.stroke();
                    }
                });
                ctx.restore();
            };

            // Main update function for the interactive chart
            const updateMainChart = () => {
                bestFitCache = null; // Invalidate cache on any change
                const slope = parseFloat(slopeSlider.value);
                const intercept = parseFloat(interceptSlider.value);

                slopeValueEl.innerHTML = slope.toFixed(2);
                interceptValueEl.innerHTML = intercept.toFixed(0);
                mseValueEl.textContent = calculateMSE(slope, intercept).toFixed(1);
                
                mainChart.data.datasets[1].data = [{ x: 0, y: intercept }, { x: 100, y: slope * 100 + intercept }];
                mainChart.update('none'); // Use 'none' for smoother updates without re-animation
            };

            // Generates new random data with a linear trend
            const generateNewData = () => {
                dataPoints = [];
                const trueSlope = Math.random() * 1.5 + 0.5;
                const trueIntercept = Math.random() * 50 + 50;
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * 90 + 5;
                    const noise = (Math.random() - 0.5) * 60;
                    const y = Math.max(0, trueSlope * x + trueIntercept + noise);
                    dataPoints.push({ x, y });
                }
                mainChart.data.datasets[0].data = dataPoints;
                updateMainChart();
            };

            // --- Chart and Visualization Creation ---

            // Creates the main interactive scatter plot
            const createMainChart = () => {
                mainChart = new Chart(mainCtx, {
                    data: {
                        datasets: [{
                            type: 'scatter',
                            label: 'Data Points',
                            data: [],
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            pointRadius: 6,
                            hoverRadius: 8
                        }, {
                            type: 'line',
                            label: 'Your Line',
                            data: [],
                            borderColor: '#4f46e5',
                            borderWidth: 4,
                            pointRadius: 0,
                            fill: false,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { min: 0, max: 100, title: { display: true, text: 'Feature (e.g., House Size)' } },
                            y: { min: 0, max: 250, title: { display: true, text: 'Outcome (e.g., Price)' } }
                        },
                        plugins: {
                            legend: { display: false }
                        }
                    },
                    plugins: [{
                        id: 'residualLinesPlugin',
                        afterDraw: drawResidualLines
                    }]
                });
            };
            
            // Creates and animates the Gradient Descent visualization
            const createGradientDescentViz = () => {
                let frame = 0;
                function draw() {
                    const w = gdCtx.canvas.width;
                    const h = gdCtx.canvas.height;
                    gdCtx.clearRect(0, 0, w, h);

                    // Draw cost surface contours
                    for (let i = 15; i > 0; i--) {
                        gdCtx.beginPath();
                        gdCtx.ellipse(w / 2, h / 2, w / 2.5 * (i / 15), h / 1.5 * (i / 15), 0, 0, 2 * Math.PI);
                        gdCtx.fillStyle = `rgba(129, 140, 248, ${0.05 + (1 - i/15)*0.15})`;
                        gdCtx.fill();
                    }

                    // Animate the point descending
                    const angle = frame * 0.05;
                    const radius = 80 * Math.exp(-frame * 0.015);
                    const x = w / 2 + radius * Math.cos(angle);
                    const y = h / 2 + radius * Math.sin(angle) * 0.6;

                    gdCtx.beginPath();
                    gdCtx.arc(x, y, 5, 0, 2 * Math.PI);
                    gdCtx.fillStyle = '#ef4444';
                    gdCtx.fill();
                    gdCtx.strokeStyle = 'white';
                    gdCtx.lineWidth = 2;
                    gdCtx.stroke();
                    
                    frame++;
                    if (radius > 1) {
                        requestAnimationFrame(draw);
                    }
                }
                gdCtx.canvas.addEventListener('click', () => { frame = 0; draw(); });
                draw();
            };

            // --- Event Listeners ---
            slopeSlider.addEventListener('input', updateMainChart);
            interceptSlider.addEventListener('input', updateMainChart);
            
            solveBtn.addEventListener('click', () => {
                const { slope, intercept } = solveForBestFit();
                slopeSlider.value = slope;
                interceptSlider.value = intercept;
                updateMainChart();
            });

            resetBtn.addEventListener('click', generateNewData);

            chartContainer.onclick = (e) => {
                const rect = mainCtx.canvas.getBoundingClientRect();
                const x = mainChart.scales.x.getValueForPixel(e.clientX - rect.left);
                const y = mainChart.scales.y.getValueForPixel(e.clientY - rect.top);

                let removed = false;
                // Check if clicking near an existing point to remove it
                for (let i = dataPoints.length - 1; i >= 0; i--) {
                    const pointElement = mainChart.getDatasetMeta(0).data[i];
                    if (pointElement && Math.sqrt(Math.pow(pointElement.x - (e.clientX - rect.left), 2) + Math.pow(pointElement.y - (e.clientY - rect.top), 2)) < 10) {
                        dataPoints.splice(i, 1);
                        removed = true;
                        break;
                    }
                }

                // If not removing, add a new point
                if (!removed && x >= 0 && x <= 100 && y >= 0 && y <= 250) {
                    dataPoints.push({ x, y });
                }
                
                mainChart.data.datasets[0].data = dataPoints;
                updateMainChart();
            };

            // --- Initial Load ---
            createMainChart();
            generateNewData();
            createGradientDescentViz();
        });
    </script>
</body>
</html>
