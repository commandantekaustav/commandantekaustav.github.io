<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide to Logistic Regression</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
            transition: all 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        .math-box {
            background-color: #f5f3ff;
            border-left: 4px solid #8b5cf6;
            padding: 1.5rem;
            border-radius: 0.5rem;
            font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 1.1rem;
            overflow-x: auto;
            color: #5b21b6;
        }
        .highlight {
            background: linear-gradient(to right, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        .action-button {
            background-color: #8b5cf6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
            text-align: center;
            border: none;
            cursor: pointer;
        }
        .action-button:hover {
            background-color: #7e22ce;
        }
        .action-button:disabled {
            background-color: #a78bfa;
            cursor: not-allowed;
        }
        .secondary-button {
            background-color: #f3e8ff;
            color: #7e22ce;
        }
        .secondary-button:hover {
             background-color: #e9d5ff;
        }
        .text-teal-700 { color: #0f766e; }
        .text-indigo-700 { color: #4338ca; }
        .text-purple-700 { color: #7e22ce; }
        .text-orange-700 { color: #c2410c; }
        .text-red-700 { color: #b91c1c; }
        .text-blue-700 { color: #1d4ed8; }
        .text-green-700 { color: #15803d; }
        .text-pink-700 { color: #be185d; }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold mb-2">
                The Intuitive Guide to <span class="highlight">Logistic Regression</span>
            </h1>
            <p class="text-lg text-gray-600">The bridge from predicting numbers to predicting categories.</p>
        </header>

        <div class="grid grid-cols-1 gap-8">

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">The Core Idea: Predicting Probabilities</h2>
                <p class="mb-4 text-gray-600 leading-relaxed">While Linear Regression predicts a continuous number (like a price), Logistic Regression predicts a category. It answers "Yes/No" questions like "Will this customer churn?" or "Is this tumor malignant?".</p>
                <p class="mb-4 text-gray-600 leading-relaxed">It does this by not predicting the category directly, but by predicting the <strong>probability</strong> of the category. For example, it might predict a 0.9 (or 90%) probability that an email is spam. We can then use a threshold (like 0.5) to make a final decision.</p>
                <p class="mb-4 text-gray-600 leading-relaxed"><strong>Analogy:</strong> Think of a doctor diagnosing a patient. They don't just say "sick" or "healthy." They might say, "Based on these symptoms, there's an 80% chance you have the flu." Logistic Regression works the same way, providing a measure of certainty for its classification.</p>
            </div>

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">Interactive Demo: Find the Dividing Line</h2>
                <p class="mb-6 text-gray-600">The data below shows hours studied versus passing (<strong class="text-green-700">1</strong>) or failing (<strong class="text-red-700">0</strong>) an exam. A straight line doesn't work well here. Instead, we use an S-shaped curve. Adjust the sliders to find the curve that best separates the two groups. Your goal is to maximize <strong class="text-green-700">Accuracy</strong> and minimize <strong class="text-red-700">Log Loss</strong>. Click "Solve for Me!" to see the algorithm find the true optimal solution.</p>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2 relative h-[450px] bg-gray-50 rounded-lg p-2">
                        <canvas id="interactiveChart"></canvas>
                    </div>
                    <div class="flex flex-col justify-center space-y-4">
                        <div>
                            <label for="slopeSlider" class="font-semibold text-purple-700">Steepness (<code>θ₁</code>): <span id="slopeValue" class="font-bold">1.0</span></label>
                            <input type="range" id="slopeSlider" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="interceptSlider" class="font-semibold text-teal-700">Position (<code>θ₀</code>): <span id="interceptValue" class="font-bold">-5.0</span></label>
                            <input type="range" id="interceptSlider" min="-20" max="5" step="0.5" value="-5" class="w-full h-2 bg-teal-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="bg-green-50 border border-green-200 rounded-lg text-center p-3">
                                <h3 class="text-lg font-bold text-green-800">Accuracy</h3>
                                <p id="accuracyValue" class="text-3xl font-bold text-green-700">0%</p>
                            </div>
                            <div class="bg-red-50 border border-red-200 rounded-lg text-center p-3">
                                <h3 class="text-lg font-bold text-red-800">Log Loss</h3>
                                <p id="loglossValue" class="text-3xl font-bold text-red-700">0.00</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <button id="solveBtn" class="action-button">Solve for Me!</button>
                            <button id="resetBtn" class="action-button secondary-button">New Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                 <h2 class="text-3xl font-bold mb-4">The Mathematics: From Line to Probability</h2>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-bold mb-2">1. The Secret Ingredient: The Sigmoid Function</h3>
                        <p class="mb-4 text-gray-600">We start with the same linear equation as before. But this equation can output any number, from negative infinity to positive infinity. We need a way to "squash" this output into a probability between 0 and 1.</p>
                        <p class="mb-4 text-gray-600"><strong>Analogy: The Probability Squeezer.</strong> Imagine a machine that can take any number, no matter how large or small, and gently squeeze it until it fits perfectly between 0 and 1. This machine is the <strong>Sigmoid (or Logistic) Function</strong>. It creates the beautiful S-shaped curve you see in the demo.</p>
                        <div class="math-box">h(x) = 1 / (1 + e<sup>-z</sup>)</div>
                        <p class="mt-2 text-gray-600 text-sm">...where <code>z</code> is our familiar linear equation: <code>z = <span class="text-teal-700">θ₀</span> + <span class="text-purple-700">θ₁</span><span class="text-orange-700">x</span></code></p>
                    </div>
                    <div>
                         <h3 class="text-xl font-bold mb-2">2. A New Cost Function: Log Loss</h3>
                        <p class="mb-4 text-gray-600">Mean Squared Error doesn't work well for classification. Instead, we use a cost function called <strong>Log Loss</strong> (or Binary Cross-Entropy).</p>
                        <p class="mb-4 text-gray-600"><strong>Analogy: The Strict Teacher.</strong> Log Loss is like a very strict teacher grading a test. If the true answer is "Pass" (1) and your model predicts a low probability like 0.01, it receives a <em>huge</em> penalty. If it predicts 0.99, the penalty is very small. It heavily punishes the model for being <strong>confidently wrong</strong>.</p>
                        <div class="math-box text-sm">J(θ) = - (1/n) * Σ [ <span class="text-green-700">yᵢ log(h(xᵢ))</span> + <span class="text-red-700">(1-yᵢ) log(1-h(xᵢ))</span> ]</div>
                         <ul class="mt-4 space-y-3 text-sm">
                            <li><strong class="text-pink-700"><code>J(θ)</code></strong>: The overall <strong>Cost</strong> we want to minimize.</li>
                            <li><strong><code>- (1/n) * Σ</code></strong>: This means "take the <strong>average negative</strong> of the sum." We use the negative because we want to minimize a cost, and log-likelihood is naturally maximized.</li>
                            <li><strong class="text-green-700"><code>yᵢ log(h(xᵢ))</code></strong>: This is the penalty for the "Pass" cases. If the true label <code>yᵢ</code> is <strong>1</strong>, this part is active. It gives a big penalty if the predicted probability <code>h(xᵢ)</code> is close to 0.</li>
                            <li><strong class="text-red-700"><code>(1-yᵢ) log(1-h(xᵢ))</code></strong>: This is the penalty for the "Fail" cases. If the true label <code>yᵢ</code> is <strong>0</strong>, this part is active. It gives a big penalty if the predicted probability <code>h(xᵢ)</code> is close to 1.</li>
                         </ul>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="text-3xl font-bold mb-4">The Decision Boundary</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                    <div>
                        <p class="mb-4 text-gray-600">Once our model is trained and can output a probability, how do we make a final decision? We set a <strong>decision boundary</strong>, which is usually at a probability of 0.5.</p>
                        <ul class="list-disc list-inside space-y-2">
                            <li>If <code>h(x) ≥ 0.5</code>, we predict the class is <strong>1</strong> (e.g., "Pass").</li>
                            <li>If <code>h(x) < 0.5</code>, we predict the class is <strong>0</strong> (e.g., "Fail").</li>
                        </ul>
                        <p class="mt-4 text-gray-600">On our chart, this corresponds to the vertical dashed line. It's the point on the x-axis where the S-curve crosses the 0.5 probability line. Any student to the right of this line is predicted to pass; any student to the left is predicted to fail.</p>
                    </div>
                    <div class="h-[250px] bg-gray-100 rounded-lg p-2">
                        <canvas id="sigmoidVizCanvas"></canvas>
                        <p class="text-center text-xs text-gray-500 mt-1">The Sigmoid Function, which maps any input value to a probability between 0 and 1.</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="text-3xl font-bold mb-4">The Code: Classification in Practice</h2>
                <p class="mb-4 text-gray-600">As with Linear Regression, Scikit-learn makes implementing Logistic Regression straightforward.</p>
                <div class="code-block">
<pre><code><span class="comment"># Import the necessary libraries</span>
<span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># 1. Your data (e.g., Hours Studied vs. Pass/Fail)</span>
X = np.array([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>], [<span class="number">7</span>], [<span class="number">8</span>]])  <span class="comment"># Feature</span>
y = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])      <span class="comment"># Target (0=Fail, 1=Pass)</span>

<span class="comment"># 2. Create and train the model</span>
<span class="comment"># The 'solver' parameter specifies the optimization algorithm to use.</span>
model = <span class="function">LogisticRegression</span>(solver=<span class="string">'lbfgs'</span>)
model.<span class="function">fit</span>(X, y)

<span class="comment"># 3. Make a prediction for a new student</span>
hours_studied = [[<span class="number">4.5</span>]]
<span class="comment"># .predict() gives the final class (0 or 1)</span>
prediction = model.<span class="function">predict</span>(hours_studied)
<span class="comment"># .predict_proba() gives the raw probabilities for each class</span>
probability = model.<span class="function">predict_proba</span>(hours_studied)

<span class="function">print</span>(<span class="string">f"Final Prediction for 4.5 hours: {'Pass' if prediction[0] == 1 else 'Fail'}"</span>)
<span class="function">print</span>(<span class="string">f"Probabilities [P(Fail), P(Pass)]: {probability[0]}"</span>)
</code></pre>
                </div>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- DOM Element Selection ---
            const slopeSlider = document.getElementById('slopeSlider');
            const interceptSlider = document.getElementById('interceptSlider');
            const slopeValueEl = document.getElementById('slopeValue');
            const interceptValueEl = document.getElementById('interceptValue');
            const accuracyValueEl = document.getElementById('accuracyValue');
            const loglossValueEl = document.getElementById('loglossValue');
            const solveBtn = document.getElementById('solveBtn');
            const resetBtn = document.getElementById('resetBtn');
            const mainCtx = document.getElementById('interactiveChart').getContext('2d');
            const sigmoidCtx = document.getElementById('sigmoidVizCanvas').getContext('2d');

            // --- State Variables ---
            let mainChart;
            let dataPoints = [];
            let isSolving = false;

            // --- Core Logic Functions ---
            const sigmoid = (z) => 1 / (1 + Math.exp(-z));

            const calculateMetrics = (slope, intercept) => {
                if (dataPoints.length === 0) return { accuracy: 0, avgLogLoss: 0 };
                let correct = 0;
                let logLoss = 0;
                const epsilon = 1e-15; // To prevent log(0) errors

                dataPoints.forEach(point => {
                    const z = slope * point.x + intercept;
                    const prob = sigmoid(z);
                    const prediction = prob >= 0.5 ? 1 : 0;
                    if (prediction === point.y) {
                        correct++;
                    }
                    const clippedProb = Math.max(epsilon, Math.min(1 - epsilon, prob));
                    logLoss += -(point.y * Math.log(clippedProb) + (1 - point.y) * Math.log(1 - clippedProb));
                });

                return {
                    accuracy: (correct / dataPoints.length) * 100,
                    avgLogLoss: logLoss / dataPoints.length
                };
            };

            const solveWithGradientDescent = async () => {
                if (isSolving) return;
                isSolving = true;
                solveBtn.disabled = true;
                solveBtn.textContent = 'Solving...';

                let theta0 = parseFloat(interceptSlider.value);
                let theta1 = parseFloat(slopeSlider.value);
                const learningRate = 0.1;
                const iterations = 500;
                const n = dataPoints.length;

                for (let i = 0; i < iterations; i++) {
                    let grad0 = 0;
                    let grad1 = 0;

                    dataPoints.forEach(p => {
                        const z = theta0 + theta1 * p.x;
                        const h = sigmoid(z);
                        const error = h - p.y;
                        grad0 += error;
                        grad1 += error * p.x;
                    });

                    theta0 -= (learningRate / n) * grad0;
                    theta1 -= (learningRate / n) * grad1;

                    if (i % 20 === 0) {
                        slopeSlider.value = theta1;
                        interceptSlider.value = theta0;
                        updateMainChart();
                        await new Promise(r => setTimeout(r, 10)); // Pause for visualization
                    }
                }
                
                slopeSlider.value = theta1;
                interceptSlider.value = theta0;
                updateMainChart();
                
                isSolving = false;
                solveBtn.disabled = false;
                solveBtn.textContent = 'Solve for Me!';
            };

            const updateMainChart = () => {
                const slope = parseFloat(slopeSlider.value);
                const intercept = parseFloat(interceptSlider.value);

                slopeValueEl.textContent = slope.toFixed(1);
                interceptValueEl.textContent = intercept.toFixed(1);

                const { accuracy, avgLogLoss } = calculateMetrics(slope, intercept);
                accuracyValueEl.textContent = `${accuracy.toFixed(1)}%`;
                loglossValueEl.textContent = avgLogLoss.toFixed(3);

                const curvePoints = Array.from({ length: 101 }, (_, i) => {
                    const x = i * 0.1;
                    return { x: x, y: sigmoid(slope * x + intercept) };
                });
                mainChart.data.datasets[2].data = curvePoints;

                // Update decision boundary
                const decisionBoundaryX = -intercept / slope;
                const annotation = mainChart.options.plugins.annotation.annotations.decisionBoundary;
                annotation.value = decisionBoundaryX;
                annotation.label.content = `Boundary at x=${decisionBoundaryX.toFixed(2)}`;
                annotation.display = (decisionBoundaryX > 0 && decisionBoundaryX < 10);

                mainChart.update('none');
            };

            const generateNewData = () => {
                dataPoints = [];
                const trueSlope = Math.random() * 1.5 + 2.0;
                const trueIntercept = -(trueSlope * (Math.random() * 2 + 4));
                for (let i = 0; i < 40; i++) {
                    const x = Math.random() * 10;
                    const z = trueSlope * x + trueIntercept + (Math.random() - 0.5) * 5;
                    const prob = sigmoid(z);
                    const y = Math.random() < prob ? 1 : 0;
                    dataPoints.push({ x, y });
                }
                mainChart.data.datasets[0].data = dataPoints.filter(p => p.y === 0);
                mainChart.data.datasets[1].data = dataPoints.filter(p => p.y === 1);
                updateMainChart();
            };

            const createMainChart = () => {
                mainChart = new Chart(mainCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            { label: 'Failed (0)', data: [], backgroundColor: 'rgba(220, 38, 38, 0.7)', pointRadius: 6, hoverRadius: 8 },
                            { label: 'Passed (1)', data: [], backgroundColor: 'rgba(22, 163, 74, 0.7)', pointRadius: 6, hoverRadius: 8 },
                            { type: 'line', label: 'Your Curve', data: [], borderColor: '#8b5cf6', borderWidth: 4, pointRadius: 0, tension: 0.1 },
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { min: 0, max: 10, title: { display: true, text: 'Hours Studied' } },
                            y: { min: -0.1, max: 1.1, title: { display: true, text: 'Probability of Passing' } }
                        },
                        plugins: {
                            legend: { display: true, position: 'bottom' },
                            annotation: {
                                annotations: {
                                    decisionBoundary: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: 5,
                                        borderColor: 'rgba(107, 114, 128, 0.7)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        label: {
                                            content: 'Boundary',
                                            enabled: true,
                                            position: 'start',
                                            backgroundColor: 'rgba(255, 255, 255, 1.0)',
                                            color: '#1f2937'
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            };

            const createSigmoidViz = () => {
                const labels = Array.from({length: 21}, (_, i) => (i - 10).toFixed(1));
                const data = labels.map(z => sigmoid(parseFloat(z)));
                new Chart(sigmoidCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Probability',
                            data: data,
                            borderColor: '#ec4899',
                            backgroundColor: 'rgba(236, 72, 153, 0.1)',
                            fill: true,
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { title: { display: true, text: 'Input (z = θ₀ + θ₁x)' } },
                            y: { min: 0, max: 1, title: { display: true, text: 'Output Probability' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            };

            // --- Event Listeners ---
            slopeSlider.addEventListener('input', updateMainChart);
            interceptSlider.addEventListener('input', updateMainChart);
            solveBtn.addEventListener('click', solveWithGradientDescent);
            resetBtn.addEventListener('click', generateNewData);

            // --- Initial Load ---
            createMainChart();
            createSigmoidViz();
            generateNewData();
        });
    </script>
</body>
</html>
